From d1d54541801b5155142031f1540e7577f60f7299 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Wed, 12 Sep 2012 22:58:11 +0200
Subject: REORG: split "protocols" files into protocol and listener

It was becoming confusing to have protocols and listeners in the same
files, split them.
---
 Makefile                   |    4 +-
 Makefile.bsd               |    4 +-
 Makefile.osx               |    4 +-
 include/proto/connection.h |    2 +-
 include/proto/listener.h   |  132 +++++++++++
 include/proto/protocol.h   |   63 +++++
 include/proto/protocols.h  |  161 -------------
 include/proto/proxy.h      |    1 +
 include/proto/ssl_sock.h   |    4 +-
 include/types/connection.h |    5 +-
 include/types/global.h     |    3 +-
 include/types/listener.h   |  168 +++++++++++++
 include/types/protocol.h   |   75 ++++++
 include/types/protocols.h  |  200 ----------------
 include/types/proxy.h      |    2 +-
 src/backend.c              |    2 +-
 src/cfgparse.c             |    3 +-
 src/dumpstats.c            |    2 +-
 src/haproxy.c              |    3 +-
 src/listener.c             |  456 ++++++++++++++++++++++++++++++++++++
 src/peers.c                |    2 +-
 src/proto_tcp.c            |    3 +-
 src/proto_uxst.c           |    3 +-
 src/protocol.c             |  129 ++++++++++
 src/protocols.c            |  559 --------------------------------------------
 src/proxy.c                |    2 +-
 src/raw_sock.c             |    1 -
 src/session.c              |    2 +-
 src/ssl_sock.c             |    1 -
 29 files changed, 1052 insertions(+), 944 deletions(-)
 create mode 100644 include/proto/listener.h
 create mode 100644 include/proto/protocol.h
 delete mode 100644 include/proto/protocols.h
 create mode 100644 include/types/listener.h
 create mode 100644 include/types/protocol.h
 delete mode 100644 include/types/protocols.h
 create mode 100644 src/listener.c
 create mode 100644 src/protocol.c
 delete mode 100644 src/protocols.c

diff --git a/Makefile b/Makefile
index e11f39a..7453198 100644
--- a/Makefile
+++ b/Makefile
@@ -560,9 +560,9 @@ else
 all: haproxy
 endif
 
-OBJS = src/haproxy.o src/sessionhash.o src/base64.o src/protocols.o \
+OBJS = src/haproxy.o src/sessionhash.o src/base64.o src/protocol.o \
        src/uri_auth.o src/standard.o src/buffer.o src/log.o src/task.o \
-       src/chunk.o src/channel.o \
+       src/chunk.o src/channel.o src/listener.o \
        src/time.o src/fd.o src/pipe.o src/regex.o src/cfgparse.o src/server.o \
        src/checks.o src/queue.o src/frontend.o src/proxy.o src/peers.o \
        src/arg.o src/stick_table.o src/proto_uxst.o src/connection.o \
diff --git a/Makefile.bsd b/Makefile.bsd
index ca00c7b..6fff29b 100644
--- a/Makefile.bsd
+++ b/Makefile.bsd
@@ -105,9 +105,9 @@ LIBS    = $(LIBS.$(TARGET)) $(LIBS.$(REGEX)) $(ADDLIB)
 CFLAGS  = -Wall $(COPTS) $(DEBUG)
 LDFLAGS = -g
 
-OBJS = src/haproxy.o src/sessionhash.o src/base64.o src/protocols.o \
+OBJS = src/haproxy.o src/sessionhash.o src/base64.o src/protocol.o \
        src/uri_auth.o src/standard.o src/buffer.o src/log.o src/task.o \
-       src/chunk.o src/channel.o \
+       src/chunk.o src/channel.o src/listener.o \
        src/time.o src/fd.o src/pipe.o src/regex.o src/cfgparse.o src/server.o \
        src/checks.o src/queue.o src/frontend.o src/proxy.o src/proto_uxst.o \
        src/proto_http.o src/raw_sock.o src/appsession.o src/backend.o \
diff --git a/Makefile.osx b/Makefile.osx
index a251c4f..8201a6a 100644
--- a/Makefile.osx
+++ b/Makefile.osx
@@ -102,9 +102,9 @@ LIBS    = $(LIBS.$(TARGET)) $(LIBS.$(REGEX)) $(ADDLIB)
 CFLAGS  = -Wall $(COPTS) $(DEBUG) -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch ppc -arch i386 -mmacosx-version-min=10.4
 LDFLAGS = -g -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch ppc -arch i386 -mmacosx-version-min=10.4
 
-OBJS = src/haproxy.o src/sessionhash.o src/base64.o src/protocols.o \
+OBJS = src/haproxy.o src/sessionhash.o src/base64.o src/protocol.o \
        src/uri_auth.o src/standard.o src/buffer.o src/log.o src/task.o \
-       src/chunk.o src/channel.o \
+       src/chunk.o src/channel.o src/listener.o \
        src/time.o src/fd.o src/pipe.o src/regex.o src/cfgparse.o src/server.o \
        src/checks.o src/queue.o src/frontend.o src/proxy.o src/proto_uxst.o \
        src/proto_http.o src/raw_sock.o src/appsession.o src/backend.o \
diff --git a/include/proto/connection.h b/include/proto/connection.h
index 3ed605f..32e77cf 100644
--- a/include/proto/connection.h
+++ b/include/proto/connection.h
@@ -24,7 +24,7 @@
 
 #include <common/config.h>
 #include <types/connection.h>
-#include <types/protocols.h>
+#include <types/listener.h>
 
 /* I/O callback for fd-based connections. It calls the read/write handlers
  * provided by the connection's sock_ops. Returns 0.
diff --git a/include/proto/listener.h b/include/proto/listener.h
new file mode 100644
index 0000000..415b913
--- /dev/null
+++ b/include/proto/listener.h
@@ -0,0 +1,132 @@
+/*
+ * include/proto/listener.h
+ * This file declares listener management primitives.
+ *
+ * Copyright (C) 2000-2012 Willy Tarreau - w@1wt.eu
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation, version 2.1
+ * exclusively.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _PROTO_LISTENER_H
+#define _PROTO_LISTENER_H
+
+#include <types/listener.h>
+
+/* This function adds the specified listener's file descriptor to the polling
+ * lists if it is in the LI_LISTEN state. The listener enters LI_READY or
+ * LI_FULL state depending on its number of connections.
+ */
+void enable_listener(struct listener *listener);
+
+/* This function removes the specified listener's file descriptor from the
+ * polling lists if it is in the LI_READY or in the LI_FULL state. The listener
+ * enters LI_LISTEN.
+ */
+void disable_listener(struct listener *listener);
+
+/* This function tries to temporarily disable a listener, depending on the OS
+ * capabilities. Linux unbinds the listen socket after a SHUT_RD, and ignores
+ * SHUT_WR. Solaris refuses either shutdown(). OpenBSD ignores SHUT_RD but
+ * closes upon SHUT_WR and refuses to rebind. So a common validation path
+ * involves SHUT_WR && listen && SHUT_RD. In case of success, the FD's polling
+ * is disabled. It normally returns non-zero, unless an error is reported.
+ */
+int pause_listener(struct listener *l);
+
+/* This function tries to resume a temporarily disabled listener.
+ * The resulting state will either be LI_READY or LI_FULL. 0 is returned
+ * in case of failure to resume (eg: dead socket).
+ */
+int resume_listener(struct listener *l);
+
+/* Marks a ready listener as full so that the session code tries to re-enable
+ * it upon next close() using resume_listener().
+ */
+void listener_full(struct listener *l);
+
+/* This function adds all of the protocol's listener's file descriptors to the
+ * polling lists when they are in the LI_LISTEN state. It is intended to be
+ * used as a protocol's generic enable_all() primitive, for use after the
+ * fork(). It puts the listeners into LI_READY or LI_FULL states depending on
+ * their number of connections. It always returns ERR_NONE.
+ */
+int enable_all_listeners(struct protocol *proto);
+
+/* This function removes all of the protocol's listener's file descriptors from
+ * the polling lists when they are in the LI_READY or LI_FULL states. It is
+ * intended to be used as a protocol's generic disable_all() primitive. It puts
+ * the listeners into LI_LISTEN, and always returns ERR_NONE.
+ */
+int disable_all_listeners(struct protocol *proto);
+
+/* Marks a ready listener as limited so that we only try to re-enable it when
+ * resources are free again. It will be queued into the specified queue.
+ */
+void limit_listener(struct listener *l, struct list *list);
+
+/* Dequeues all of the listeners waiting for a resource in wait queue <queue>. */
+void dequeue_all_listeners(struct list *list);
+
+/* This function closes the listening socket for the specified listener,
+ * provided that it's already in a listening state. The listener enters the
+ * LI_ASSIGNED state. It always returns ERR_NONE. This function is intended
+ * to be used as a generic function for standard protocols.
+ */
+int unbind_listener(struct listener *listener);
+
+/* This function closes all listening sockets bound to the protocol <proto>,
+ * and the listeners end in LI_ASSIGNED state if they were higher. It does not
+ * detach them from the protocol. It always returns ERR_NONE.
+ */
+int unbind_all_listeners(struct protocol *proto);
+
+/* Delete a listener from its protocol's list of listeners. The listener's
+ * state is automatically updated from LI_ASSIGNED to LI_INIT. The protocol's
+ * number of listeners is updated. Note that the listener must have previously
+ * been unbound. This is the generic function to use to remove a listener.
+ */
+void delete_listener(struct listener *listener);
+
+/* This function is called on a read event from a listening socket, corresponding
+ * to an accept. It tries to accept as many connections as possible, and for each
+ * calls the listener's accept handler (generally the frontend's accept handler).
+ */
+int listener_accept(int fd);
+
+/* allocate an ssl_conf struct for a bind line, and chain it to list head <lh>.
+ * If <arg> is not NULL, it is duplicated into ->arg to store useful config
+ * information for error reporting.
+ */
+static inline struct ssl_conf *ssl_conf_alloc(struct list *lh, const char *file, int line, const char *arg)
+{
+	struct ssl_conf *ssl_conf = (void *)calloc(1, sizeof(struct ssl_conf));
+
+	ssl_conf->file = strdup(file);
+	ssl_conf->line = line;
+	if (lh)
+		LIST_ADDQ(lh, &ssl_conf->by_fe);
+	if (arg)
+		ssl_conf->arg = strdup(arg);
+	return ssl_conf;
+}
+
+#endif /* _PROTO_LISTENER_H */
+
+/*
+ * Local variables:
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ * End:
+ */
diff --git a/include/proto/protocol.h b/include/proto/protocol.h
new file mode 100644
index 0000000..1842faf
--- /dev/null
+++ b/include/proto/protocol.h
@@ -0,0 +1,63 @@
+/*
+ * include/proto/protocol.h
+ * This file declares generic protocol management primitives.
+ *
+ * Copyright (C) 2000-2012 Willy Tarreau - w@1wt.eu
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation, version 2.1
+ * exclusively.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _PROTO_PROTOCOL_H
+#define _PROTO_PROTOCOL_H
+
+#include <types/protocol.h>
+
+/* Registers the protocol <proto> */
+void protocol_register(struct protocol *proto);
+
+/* Unregisters the protocol <proto>. Note that all listeners must have
+ * previously been unbound.
+ */
+void protocol_unregister(struct protocol *proto);
+
+/* binds all listeneres of all registered protocols. Returns a composition
+ * of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
+ */
+int protocol_bind_all(char *errmsg, int errlen);
+
+/* unbinds all listeners of all registered protocols. They are also closed.
+ * This must be performed before calling exit() in order to get a chance to
+ * remove file-system based sockets and pipes.
+ * Returns a composition of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
+ */
+int protocol_unbind_all(void);
+
+/* enables all listeners of all registered protocols. This is intended to be
+ * used after a fork() to enable reading on all file descriptors. Returns a
+ * composition of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
+ */
+int protocol_enable_all(void);
+
+/* returns the protocol associated to family <family> or NULL if not found */
+struct protocol *protocol_by_family(int family);
+
+#endif /* _PROTO_PROTOCOL_H */
+
+/*
+ * Local variables:
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ * End:
+ */
diff --git a/include/proto/protocols.h b/include/proto/protocols.h
deleted file mode 100644
index ec98e59..0000000
--- a/include/proto/protocols.h
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
-  include/proto/protocols.h
-  This file declares generic protocol primitives.
-
-  Copyright (C) 2000-2007 Willy Tarreau - w@1wt.eu
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation, version 2.1
-  exclusively.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef _PROTO_PROTOCOLS_H
-#define _PROTO_PROTOCOLS_H
-
-#include <types/protocols.h>
-
-/* This function adds the specified listener's file descriptor to the polling
- * lists if it is in the LI_LISTEN state. The listener enters LI_READY or
- * LI_FULL state depending on its number of connections.
- */
-void enable_listener(struct listener *listener);
-
-/* This function removes the specified listener's file descriptor from the
- * polling lists if it is in the LI_READY or in the LI_FULL state. The listener
- * enters LI_LISTEN.
- */
-void disable_listener(struct listener *listener);
-
-/* This function tries to temporarily disable a listener, depending on the OS
- * capabilities. Linux unbinds the listen socket after a SHUT_RD, and ignores
- * SHUT_WR. Solaris refuses either shutdown(). OpenBSD ignores SHUT_RD but
- * closes upon SHUT_WR and refuses to rebind. So a common validation path
- * involves SHUT_WR && listen && SHUT_RD. In case of success, the FD's polling
- * is disabled. It normally returns non-zero, unless an error is reported.
- */
-int pause_listener(struct listener *l);
-
-/* This function tries to resume a temporarily disabled listener.
- * The resulting state will either be LI_READY or LI_FULL. 0 is returned
- * in case of failure to resume (eg: dead socket).
- */
-int resume_listener(struct listener *l);
-
-/* Marks a ready listener as full so that the session code tries to re-enable
- * it upon next close() using resume_listener().
- */
-void listener_full(struct listener *l);
-
-/* This function adds all of the protocol's listener's file descriptors to the
- * polling lists when they are in the LI_LISTEN state. It is intended to be
- * used as a protocol's generic enable_all() primitive, for use after the
- * fork(). It puts the listeners into LI_READY or LI_FULL states depending on
- * their number of connections. It always returns ERR_NONE.
- */
-int enable_all_listeners(struct protocol *proto);
-
-/* This function removes all of the protocol's listener's file descriptors from
- * the polling lists when they are in the LI_READY or LI_FULL states. It is
- * intended to be used as a protocol's generic disable_all() primitive. It puts
- * the listeners into LI_LISTEN, and always returns ERR_NONE.
- */
-int disable_all_listeners(struct protocol *proto);
-
-/* Marks a ready listener as limited so that we only try to re-enable it when
- * resources are free again. It will be queued into the specified queue.
- */
-void limit_listener(struct listener *l, struct list *list);
-
-/* Dequeues all of the listeners waiting for a resource in wait queue <queue>. */
-void dequeue_all_listeners(struct list *list);
-
-/* This function closes the listening socket for the specified listener,
- * provided that it's already in a listening state. The listener enters the
- * LI_ASSIGNED state. It always returns ERR_NONE. This function is intended
- * to be used as a generic function for standard protocols.
- */
-int unbind_listener(struct listener *listener);
-
-/* This function closes all listening sockets bound to the protocol <proto>,
- * and the listeners end in LI_ASSIGNED state if they were higher. It does not
- * detach them from the protocol. It always returns ERR_NONE.
- */
-int unbind_all_listeners(struct protocol *proto);
-
-/* Delete a listener from its protocol's list of listeners. The listener's
- * state is automatically updated from LI_ASSIGNED to LI_INIT. The protocol's
- * number of listeners is updated. Note that the listener must have previously
- * been unbound. This is the generic function to use to remove a listener.
- */
-void delete_listener(struct listener *listener);
-
-/* This function is called on a read event from a listening socket, corresponding
- * to an accept. It tries to accept as many connections as possible, and for each
- * calls the listener's accept handler (generally the frontend's accept handler).
- */
-int listener_accept(int fd);
-
-/* Registers the protocol <proto> */
-void protocol_register(struct protocol *proto);
-
-/* Unregisters the protocol <proto>. Note that all listeners must have
- * previously been unbound.
- */
-void protocol_unregister(struct protocol *proto);
-
-/* binds all listeneres of all registered protocols. Returns a composition
- * of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_bind_all(char *errmsg, int errlen);
-
-/* unbinds all listeners of all registered protocols. They are also closed.
- * This must be performed before calling exit() in order to get a chance to
- * remove file-system based sockets and pipes.
- * Returns a composition of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_unbind_all(void);
-
-/* enables all listeners of all registered protocols. This is intended to be
- * used after a fork() to enable reading on all file descriptors. Returns a
- * composition of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_enable_all(void);
-
-/* returns the protocol associated to family <family> or NULL if not found */
-struct protocol *protocol_by_family(int family);
-
-/* allocate an ssl_conf struct for a bind line, and chain it to list head <lh>.
- * If <arg> is not NULL, it is duplicated into ->arg to store useful config
- * information for error reporting.
- */
-static inline struct ssl_conf *ssl_conf_alloc(struct list *lh, const char *file, int line, const char *arg)
-{
-	struct ssl_conf *ssl_conf = (void *)calloc(1, sizeof(struct ssl_conf));
-
-	ssl_conf->file = strdup(file);
-	ssl_conf->line = line;
-	if (lh)
-		LIST_ADDQ(lh, &ssl_conf->by_fe);
-	if (arg)
-		ssl_conf->arg = strdup(arg);
-	return ssl_conf;
-}
-
-#endif /* _PROTO_PROTOCOLS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/include/proto/proxy.h b/include/proto/proxy.h
index d5fd3e0..4a4b285 100644
--- a/include/proto/proxy.h
+++ b/include/proto/proxy.h
@@ -27,6 +27,7 @@
 #include <common/time.h>
 #include <types/global.h>
 #include <types/proxy.h>
+#include <types/listener.h>
 #include <proto/freq_ctr.h>
 
 int start_proxies(int verbose);
diff --git a/include/proto/ssl_sock.h b/include/proto/ssl_sock.h
index 9d04624..6192fe8 100644
--- a/include/proto/ssl_sock.h
+++ b/include/proto/ssl_sock.h
@@ -23,7 +23,9 @@
 #define _PROTO_SSL_SOCK_H
 #include <openssl/ssl.h>
 
-#include <types/protocols.h>
+#include <types/connection.h>
+#include <types/listener.h>
+#include <types/proxy.h>
 #include <types/stream_interface.h>
 
 extern struct data_ops ssl_sock;
diff --git a/include/types/connection.h b/include/types/connection.h
index 711abf0..8a1b8ee 100644
--- a/include/types/connection.h
+++ b/include/types/connection.h
@@ -27,8 +27,10 @@
 
 #include <common/config.h>
 
+#include <types/listener.h>
+#include <types/protocol.h>
+
 /* referenced below */
-struct protocol;
 struct connection;
 struct buffer;
 struct pipe;
@@ -36,7 +38,6 @@ struct server;
 struct proxy;
 struct si_applet;
 struct task;
-struct listener;
 
 /* Polling flags that are manipulated by I/O callbacks and handshake callbacks
  * indicate what they expect from a file descriptor at each layer. For each
diff --git a/include/types/global.h b/include/types/global.h
index 5775e27..4c0e443 100644
--- a/include/types/global.h
+++ b/include/types/global.h
@@ -26,8 +26,7 @@
 
 #include <common/config.h>
 #include <types/freq_ctr.h>
-#include <types/log.h>
-#include <types/protocols.h>
+#include <types/listener.h>
 #include <types/proxy.h>
 #include <types/task.h>
 
diff --git a/include/types/listener.h b/include/types/listener.h
new file mode 100644
index 0000000..78195ec
--- /dev/null
+++ b/include/types/listener.h
@@ -0,0 +1,168 @@
+/*
+ * include/types/listener.h
+ * This file defines the structures needed to manage listeners.
+ *
+ * Copyright (C) 2000-2012 Willy Tarreau - w@1wt.eu
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation, version 2.1
+ * exclusively.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TYPES_LISTENER_H
+#define _TYPES_LISTENER_H
+
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#ifdef USE_OPENSSL
+#include <openssl/ssl.h>
+#endif
+
+#include <common/config.h>
+#include <common/mini-clist.h>
+#include <eb32tree.h>
+
+/* Some pointer types reference below */
+struct task;
+struct protocol;
+struct data_ops;
+struct proxy;
+struct licounters;
+
+/* listener state */
+enum {
+	LI_NEW	= 0,    /* not initialized yet */
+	LI_INIT,        /* all parameters filled in, but not assigned yet */
+	LI_ASSIGNED,    /* assigned to the protocol, but not listening yet */
+	LI_PAUSED,      /* listener was paused, it's bound but not listening  */
+	LI_LISTEN,      /* started, listening but not enabled */
+	LI_READY,       /* started, listening and enabled */
+	LI_FULL,        /* reached its connection limit */
+	LI_LIMITED,     /* transient state: limits have been reached, listener is queued */
+};
+
+/* Listener transitions
+ * calloc()     set()      add_listener()       bind()
+ * -------> NEW ----> INIT ----------> ASSIGNED -----> LISTEN
+ * <-------     <----      <----------          <-----
+ *    free()   bzero()     del_listener()       unbind()
+ *
+ * The file descriptor is valid only during these three states :
+ *
+ *             disable()
+ * LISTEN <------------ READY
+ *   A|   ------------>  |A
+ *   ||  !max & enable() ||
+ *   ||                  ||
+ *   ||              max ||
+ *   || max & enable()   V| !max
+ *   |+---------------> FULL
+ *   +-----------------
+ *            disable()
+ *
+ * The LIMITED state my be used when a limit has been detected just before
+ * using a listener. In this case, the listener MUST be queued into the
+ * appropriate wait queue (either the proxy's or the global one). It may be
+ * set back to the READY state at any instant and for any reason, so one must
+ * not rely on this state.
+ */
+
+/* listener socket options */
+#define LI_O_NONE	0x0000
+#define LI_O_NOLINGER	0x0001	/* disable linger on this socket */
+#define LI_O_FOREIGN	0x0002	/* permit listening on foreing addresses */
+#define LI_O_NOQUICKACK	0x0004	/* disable quick ack of immediate data (linux) */
+#define LI_O_DEF_ACCEPT	0x0008	/* wait up to 1 second for data before accepting */
+#define LI_O_TCP_RULES  0x0010  /* run TCP rules checks on the incoming connection */
+#define LI_O_CHK_MONNET 0x0020  /* check the source against a monitor-net rule */
+#define LI_O_ACC_PROXY  0x0040  /* find the proxied address in the first request line */
+#define LI_O_UNLIMITED  0x0080  /* listener not subject to global limits (peers & stats socket) */
+
+/* Note: if a listener uses LI_O_UNLIMITED, it is highly recommended that it adds its own
+ * maxconn setting to the global.maxsock value so that its resources are reserved.
+ */
+
+/* "bind" line SSL settings */
+struct ssl_conf {
+#ifdef USE_OPENSSL
+	char *ciphers;             /* cipher suite to use if non-null */
+	int nosslv3;               /* disable SSLv3 */
+	int notlsv1;               /* disable TLSv1 */
+	int prefer_server_ciphers; /* Prefer server ciphers */
+	SSL_CTX *default_ctx;      /* SSL context of first/default certificate */
+	struct eb_root sni_ctx;    /* sni_ctx tree of all known certs full-names sorted by name */
+	struct eb_root sni_w_ctx;  /* sni_ctx tree of all known certs wildcards sorted by name */
+#endif
+	int ref_cnt;               /* number of users of this config, maybe 0 on error */
+	struct list by_fe;         /* next binding for the same frontend, or NULL */
+	char *arg;                 /* argument passed to "bind" for better error reporting */
+	char *file;                /* file where the section appears */
+	int line;                  /* line where the section appears */
+};
+
+/* The listener will be directly referenced by the fdtab[] which holds its
+ * socket. The listener provides the protocol-specific accept() function to
+ * the fdtab.
+ */
+struct listener {
+	int fd;				/* the listen socket */
+	char *name;			/* */
+	int luid;			/* listener universally unique ID, used for SNMP */
+	int state;			/* state: NEW, INIT, ASSIGNED, LISTEN, READY, FULL */
+	int options;			/* socket options : LI_O_* */
+	struct licounters *counters;	/* statistics counters */
+	struct protocol *proto;		/* protocol this listener belongs to */
+	struct data_ops *data;          /* data-layer operations operations for this socket */
+	int nbconn;			/* current number of connections on this listener */
+	int maxconn;			/* maximum connections allowed on this listener */
+	unsigned int backlog;		/* if set, listen backlog */
+	struct listener *next;		/* next address for the same proxy, or NULL */
+	struct list proto_list;         /* list in the protocol header */
+	int (*accept)(struct listener *l, int fd, struct sockaddr_storage *addr); /* upper layer's accept() */
+	struct task * (*handler)(struct task *t); /* protocol handler. It is a task */
+	int  *timeout;                  /* pointer to client-side timeout */
+	struct proxy *frontend;		/* the frontend this listener belongs to, or NULL */
+	struct list wait_queue;		/* link element to make the listener wait for something (LI_LIMITED)  */
+	unsigned int analysers;		/* bitmap of required protocol analysers */
+	int nice;			/* nice value to assign to the instanciated tasks */
+	union {				/* protocol-dependant access restrictions */
+		struct {		/* UNIX socket permissions */
+			uid_t uid;	/* -1 to leave unchanged */
+			gid_t gid;	/* -1 to leave unchanged */
+			mode_t mode;	/* 0 to leave unchanged */
+			int level;	/* access level (ACCESS_LVL_*) */
+		} ux;
+	} perm;
+	char *interface;		/* interface name or NULL */
+	int maxseg;			/* for TCP, advertised MSS */
+
+	struct ssl_conf *ssl_conf;	/* SSL settings, otherwise NULL */
+
+	/* warning: this struct is huge, keep it at the bottom */
+	struct sockaddr_storage addr;	/* the address we listen to */
+	struct {
+		const char *file;	/* file where the section appears */
+		int line;		/* line where the section appears */
+		struct eb32_node id;	/* place in the tree of used IDs */
+	} conf;				/* config information */
+};
+
+#endif /* _TYPES_LISTENER_H */
+
+/*
+ * Local variables:
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ * End:
+ */
diff --git a/include/types/protocol.h b/include/types/protocol.h
new file mode 100644
index 0000000..a8e020c
--- /dev/null
+++ b/include/types/protocol.h
@@ -0,0 +1,75 @@
+/*
+ * include/types/protocol.h
+ * This file defines the structures used by generic network protocols.
+ *
+ * Copyright (C) 2000-2012 Willy Tarreau - w@1wt.eu
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation, version 2.1
+ * exclusively.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _TYPES_PROTOCOL_H
+#define _TYPES_PROTOCOL_H
+
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <common/config.h>
+#include <common/mini-clist.h>
+#include <eb32tree.h>
+
+/* some pointer types referenced below */
+struct listener;
+struct connection;
+
+/* max length of a protcol name, including trailing zero */
+#define PROTO_NAME_LEN 16
+
+/* This structure contains all information needed to easily handle a protocol.
+ * Its primary goal is to ease listeners maintenance. Specifically, the
+ * bind_all() primitive must be used before any fork(), and the enable_all()
+ * primitive must be called after the fork() to enable all fds. Last, the
+ * unbind_all() primitive closes all listeners.
+ */
+struct protocol {
+	char name[PROTO_NAME_LEN];			/* protocol name, zero-terminated */
+	int sock_domain;				/* socket domain, as passed to socket()   */
+	int sock_type;					/* socket type, as passed to socket()     */
+	int sock_prot;					/* socket protocol, as passed to socket() */
+	sa_family_t sock_family;			/* socket family, for sockaddr */
+	socklen_t sock_addrlen;				/* socket address length, used by bind() */
+	int l3_addrlen;					/* layer3 address length, used by hashes */
+	int (*accept)(int fd);				/* generic accept function */
+	int (*bind)(struct listener *l, char *errmsg, int errlen); /* bind a listener */
+	int (*bind_all)(struct protocol *proto, char *errmsg, int errlen); /* bind all unbound listeners */
+	int (*unbind_all)(struct protocol *proto);	/* unbind all bound listeners */
+	int (*enable_all)(struct protocol *proto);	/* enable all bound listeners */
+	int (*disable_all)(struct protocol *proto);	/* disable all bound listeners */
+	int (*connect)(struct connection *, int data);  /* connect function if any */
+	int (*get_src)(int fd, struct sockaddr *, socklen_t, int dir); /* syscall used to retrieve src addr */
+	int (*get_dst)(int fd, struct sockaddr *, socklen_t, int dir); /* syscall used to retrieve dst addr */
+
+	struct list listeners;				/* list of listeners using this protocol */
+	int nb_listeners;				/* number of listeners */
+	struct list list;				/* list of registered protocols */
+};
+
+#endif /* _TYPES_PROTOCOL_H */
+
+/*
+ * Local variables:
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ * End:
+ */
diff --git a/include/types/protocols.h b/include/types/protocols.h
deleted file mode 100644
index bd8b355..0000000
--- a/include/types/protocols.h
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * include/types/protocols.h
- * This file defines the structures used by generic network protocols.
- *
- * Copyright (C) 2000-2011 Willy Tarreau - w@1wt.eu
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation, version 2.1
- * exclusively.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef _TYPES_PROTOCOLS_H
-#define _TYPES_PROTOCOLS_H
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/un.h>
-
-#ifdef USE_OPENSSL
-#include <openssl/ssl.h>
-#endif
-
-#include <common/config.h>
-#include <common/mini-clist.h>
-#include <eb32tree.h>
-
-#include <types/counters.h>
-#include <types/task.h>
-
-/* max length of a protcol name, including trailing zero */
-#define PROTO_NAME_LEN 16
-
-/* listener state */
-enum {
-	LI_NEW	= 0,    /* not initialized yet */
-	LI_INIT,        /* all parameters filled in, but not assigned yet */
-	LI_ASSIGNED,    /* assigned to the protocol, but not listening yet */
-	LI_PAUSED,      /* listener was paused, it's bound but not listening  */
-	LI_LISTEN,      /* started, listening but not enabled */
-	LI_READY,       /* started, listening and enabled */
-	LI_FULL,        /* reached its connection limit */
-	LI_LIMITED,     /* transient state: limits have been reached, listener is queued */
-};
-
-/* Listener transitions
- * calloc()     set()      add_listener()       bind()
- * -------> NEW ----> INIT ----------> ASSIGNED -----> LISTEN
- * <-------     <----      <----------          <-----
- *    free()   bzero()     del_listener()       unbind()
- *
- * The file descriptor is valid only during these three states :
- *
- *             disable()
- * LISTEN <------------ READY
- *   A|   ------------>  |A
- *   ||  !max & enable() ||
- *   ||                  ||
- *   ||              max ||
- *   || max & enable()   V| !max
- *   |+---------------> FULL
- *   +-----------------
- *            disable()
- *
- * The LIMITED state my be used when a limit has been detected just before
- * using a listener. In this case, the listener MUST be queued into the
- * appropriate wait queue (either the proxy's or the global one). It may be
- * set back to the READY state at any instant and for any reason, so one must
- * not rely on this state.
- */
-
-/* listener socket options */
-#define LI_O_NONE	0x0000
-#define LI_O_NOLINGER	0x0001	/* disable linger on this socket */
-#define LI_O_FOREIGN	0x0002	/* permit listening on foreing addresses */
-#define LI_O_NOQUICKACK	0x0004	/* disable quick ack of immediate data (linux) */
-#define LI_O_DEF_ACCEPT	0x0008	/* wait up to 1 second for data before accepting */
-#define LI_O_TCP_RULES  0x0010  /* run TCP rules checks on the incoming connection */
-#define LI_O_CHK_MONNET 0x0020  /* check the source against a monitor-net rule */
-#define LI_O_ACC_PROXY  0x0040  /* find the proxied address in the first request line */
-#define LI_O_UNLIMITED  0x0080  /* listener not subject to global limits (peers & stats socket) */
-
-/* Note: if a listener uses LI_O_UNLIMITED, it is highly recommended that it adds its own
- * maxconn setting to the global.maxsock value so that its resources are reserved.
- */
-
-/* "bind" line SSL settings */
-struct ssl_conf {
-#ifdef USE_OPENSSL
-	char *ciphers;             /* cipher suite to use if non-null */
-	int nosslv3;               /* disable SSLv3 */
-	int notlsv1;               /* disable TLSv1 */
-	int prefer_server_ciphers; /* Prefer server ciphers */
-	SSL_CTX *default_ctx;      /* SSL context of first/default certificate */
-	struct eb_root sni_ctx;    /* sni_ctx tree of all known certs full-names sorted by name */
-	struct eb_root sni_w_ctx;  /* sni_ctx tree of all known certs wildcards sorted by name */
-#endif
-	int ref_cnt;               /* number of users of this config, maybe 0 on error */
-	struct list by_fe;         /* next binding for the same frontend, or NULL */
-	char *arg;                 /* argument passed to "bind" for better error reporting */
-	char *file;                /* file where the section appears */
-	int line;                  /* line where the section appears */
-};
-
-/* The listener will be directly referenced by the fdtab[] which holds its
- * socket. The listener provides the protocol-specific accept() function to
- * the fdtab.
- */
-struct listener {
-	int fd;				/* the listen socket */
-	char *name;			/* */
-	int luid;			/* listener universally unique ID, used for SNMP */
-	int state;			/* state: NEW, INIT, ASSIGNED, LISTEN, READY, FULL */
-	int options;			/* socket options : LI_O_* */
-	struct licounters *counters;	/* statistics counters */
-	struct protocol *proto;		/* protocol this listener belongs to */
-	struct data_ops *data;          /* data-layer operations operations for this socket */
-	int nbconn;			/* current number of connections on this listener */
-	int maxconn;			/* maximum connections allowed on this listener */
-	unsigned int backlog;		/* if set, listen backlog */
-	struct listener *next;		/* next address for the same proxy, or NULL */
-	struct list proto_list;         /* list in the protocol header */
-	int (*accept)(struct listener *l, int fd, struct sockaddr_storage *addr); /* upper layer's accept() */
-	struct task * (*handler)(struct task *t); /* protocol handler. It is a task */
-	int  *timeout;                  /* pointer to client-side timeout */
-	struct proxy *frontend;		/* the frontend this listener belongs to, or NULL */
-	struct list wait_queue;		/* link element to make the listener wait for something (LI_LIMITED)  */
-	unsigned int analysers;		/* bitmap of required protocol analysers */
-	int nice;			/* nice value to assign to the instanciated tasks */
-	union {				/* protocol-dependant access restrictions */
-		struct {		/* UNIX socket permissions */
-			uid_t uid;	/* -1 to leave unchanged */
-			gid_t gid;	/* -1 to leave unchanged */
-			mode_t mode;	/* 0 to leave unchanged */
-			int level;	/* access level (ACCESS_LVL_*) */
-		} ux;
-	} perm;
-	char *interface;		/* interface name or NULL */
-	int maxseg;			/* for TCP, advertised MSS */
-
-	struct ssl_conf *ssl_conf;	/* SSL settings, otherwise NULL */
-
-	/* warning: this struct is huge, keep it at the bottom */
-	struct sockaddr_storage addr;	/* the address we listen to */
-	struct {
-		const char *file;	/* file where the section appears */
-		int line;		/* line where the section appears */
-		struct eb32_node id;	/* place in the tree of used IDs */
-	} conf;				/* config information */
-};
-
-struct connection;
-
-/* This structure contains all information needed to easily handle a protocol.
- * Its primary goal is to ease listeners maintenance. Specifically, the
- * bind_all() primitive must be used before any fork(), and the enable_all()
- * primitive must be called after the fork() to enable all fds. Last, the
- * unbind_all() primitive closes all listeners.
- */
-struct protocol {
-	char name[PROTO_NAME_LEN];			/* protocol name, zero-terminated */
-	int sock_domain;				/* socket domain, as passed to socket()   */
-	int sock_type;					/* socket type, as passed to socket()     */
-	int sock_prot;					/* socket protocol, as passed to socket() */
-	sa_family_t sock_family;			/* socket family, for sockaddr */
-	socklen_t sock_addrlen;				/* socket address length, used by bind() */
-	int l3_addrlen;					/* layer3 address length, used by hashes */
-	int (*accept)(int fd);				/* generic accept function */
-	int (*bind)(struct listener *l, char *errmsg, int errlen); /* bind a listener */
-	int (*bind_all)(struct protocol *proto, char *errmsg, int errlen); /* bind all unbound listeners */
-	int (*unbind_all)(struct protocol *proto);	/* unbind all bound listeners */
-	int (*enable_all)(struct protocol *proto);	/* enable all bound listeners */
-	int (*disable_all)(struct protocol *proto);	/* disable all bound listeners */
-	int (*connect)(struct connection *, int data);  /* connect function if any */
-	int (*get_src)(int fd, struct sockaddr *, socklen_t, int dir); /* syscall used to retrieve src addr */
-	int (*get_dst)(int fd, struct sockaddr *, socklen_t, int dir); /* syscall used to retrieve dst addr */
-
-	struct list listeners;				/* list of listeners using this protocol */
-	int nb_listeners;				/* number of listeners */
-	struct list list;				/* list of registered protocols */
-};
-
-#endif /* _TYPES_PROTOCOLS_H */
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/include/types/proxy.h b/include/types/proxy.h
index 1080568..a2355d5 100644
--- a/include/types/proxy.h
+++ b/include/types/proxy.h
@@ -40,8 +40,8 @@
 #include <types/backend.h>
 #include <types/counters.h>
 #include <types/freq_ctr.h>
+#include <types/listener.h>
 #include <types/log.h>
-#include <types/protocols.h>
 #include <types/proto_http.h>
 #include <types/sample.h>
 #include <types/session.h>
diff --git a/src/backend.c b/src/backend.c
index c2ecda8..29d8145 100644
--- a/src/backend.c
+++ b/src/backend.c
@@ -38,7 +38,7 @@
 #include <proto/lb_fwlc.h>
 #include <proto/lb_fwrr.h>
 #include <proto/lb_map.h>
-#include <proto/protocols.h>
+#include <proto/protocol.h>
 #include <proto/proto_http.h>
 #include <proto/proto_tcp.h>
 #include <proto/queue.h>
diff --git a/src/cfgparse.c b/src/cfgparse.c
index c91e996..f78f896 100644
--- a/src/cfgparse.c
+++ b/src/cfgparse.c
@@ -51,9 +51,10 @@
 #include <proto/lb_fwlc.h>
 #include <proto/lb_fwrr.h>
 #include <proto/lb_map.h>
+#include <proto/listener.h>
 #include <proto/log.h>
 #include <proto/port_range.h>
-#include <proto/protocols.h>
+#include <proto/protocol.h>
 #include <proto/proto_tcp.h>
 #include <proto/proto_uxst.h>
 #include <proto/proto_http.h>
diff --git a/src/dumpstats.c b/src/dumpstats.c
index 2e775d9..e28f808 100644
--- a/src/dumpstats.c
+++ b/src/dumpstats.c
@@ -47,7 +47,7 @@
 #include <proto/freq_ctr.h>
 #include <proto/log.h>
 #include <proto/pipe.h>
-#include <proto/protocols.h>
+#include <proto/listener.h>
 #include <proto/proto_uxst.h>
 #include <proto/proxy.h>
 #include <proto/session.h>
diff --git a/src/haproxy.c b/src/haproxy.c
index 7fb0429..5edde4f 100644
--- a/src/haproxy.c
+++ b/src/haproxy.c
@@ -78,8 +78,9 @@
 #include <proto/checks.h>
 #include <proto/fd.h>
 #include <proto/hdr_idx.h>
+#include <proto/listener.h>
 #include <proto/log.h>
-#include <proto/protocols.h>
+#include <proto/protocol.h>
 #include <proto/proto_http.h>
 #include <proto/proxy.h>
 #include <proto/queue.h>
diff --git a/src/listener.c b/src/listener.c
new file mode 100644
index 0000000..0e864b2
--- /dev/null
+++ b/src/listener.c
@@ -0,0 +1,456 @@
+/*
+ * Listener management functions.
+ *
+ * Copyright 2000-2012 Willy Tarreau <w@1wt.eu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <common/config.h>
+#include <common/errors.h>
+#include <common/mini-clist.h>
+#include <common/standard.h>
+#include <common/time.h>
+
+#include <types/global.h>
+#include <types/protocol.h>
+
+#include <proto/acl.h>
+#include <proto/fd.h>
+#include <proto/freq_ctr.h>
+#include <proto/log.h>
+#include <proto/task.h>
+
+/* This function adds the specified listener's file descriptor to the polling
+ * lists if it is in the LI_LISTEN state. The listener enters LI_READY or
+ * LI_FULL state depending on its number of connections.
+ */
+void enable_listener(struct listener *listener)
+{
+	if (listener->state == LI_LISTEN) {
+		if (listener->nbconn < listener->maxconn) {
+			fd_want_recv(listener->fd);
+			listener->state = LI_READY;
+		} else {
+			listener->state = LI_FULL;
+		}
+	}
+}
+
+/* This function removes the specified listener's file descriptor from the
+ * polling lists if it is in the LI_READY or in the LI_FULL state. The listener
+ * enters LI_LISTEN.
+ */
+void disable_listener(struct listener *listener)
+{
+	if (listener->state < LI_READY)
+		return;
+	if (listener->state == LI_READY)
+		fd_stop_recv(listener->fd);
+	if (listener->state == LI_LIMITED)
+		LIST_DEL(&listener->wait_queue);
+	listener->state = LI_LISTEN;
+}
+
+/* This function tries to temporarily disable a listener, depending on the OS
+ * capabilities. Linux unbinds the listen socket after a SHUT_RD, and ignores
+ * SHUT_WR. Solaris refuses either shutdown(). OpenBSD ignores SHUT_RD but
+ * closes upon SHUT_WR and refuses to rebind. So a common validation path
+ * involves SHUT_WR && listen && SHUT_RD. In case of success, the FD's polling
+ * is disabled. It normally returns non-zero, unless an error is reported.
+ */
+int pause_listener(struct listener *l)
+{
+	if (l->state <= LI_PAUSED)
+		return 1;
+
+	if (shutdown(l->fd, SHUT_WR) != 0)
+		return 0; /* Solaris dies here */
+
+	if (listen(l->fd, l->backlog ? l->backlog : l->maxconn) != 0)
+		return 0; /* OpenBSD dies here */
+
+	if (shutdown(l->fd, SHUT_RD) != 0)
+		return 0; /* should always be OK */
+
+	if (l->state == LI_LIMITED)
+		LIST_DEL(&l->wait_queue);
+
+	fd_stop_recv(l->fd);
+	l->state = LI_PAUSED;
+	return 1;
+}
+
+/* This function tries to resume a temporarily disabled listener. Paused, full,
+ * limited and disabled listeners are handled, which means that this function
+ * may replace enable_listener(). The resulting state will either be LI_READY
+ * or LI_FULL. 0 is returned in case of failure to resume (eg: dead socket).
+ */
+int resume_listener(struct listener *l)
+{
+	if (l->state < LI_PAUSED)
+		return 0;
+
+	if (l->state == LI_PAUSED &&
+	    listen(l->fd, l->backlog ? l->backlog : l->maxconn) != 0)
+		return 0;
+
+	if (l->state == LI_READY)
+		return 1;
+
+	if (l->state == LI_LIMITED)
+		LIST_DEL(&l->wait_queue);
+
+	if (l->nbconn >= l->maxconn) {
+		l->state = LI_FULL;
+		return 1;
+	}
+
+	fd_want_recv(l->fd);
+	l->state = LI_READY;
+	return 1;
+}
+
+/* Marks a ready listener as full so that the session code tries to re-enable
+ * it upon next close() using resume_listener().
+ */
+void listener_full(struct listener *l)
+{
+	if (l->state >= LI_READY) {
+		if (l->state == LI_LIMITED)
+			LIST_DEL(&l->wait_queue);
+
+		fd_stop_recv(l->fd);
+		l->state = LI_FULL;
+	}
+}
+
+/* Marks a ready listener as limited so that we only try to re-enable it when
+ * resources are free again. It will be queued into the specified queue.
+ */
+void limit_listener(struct listener *l, struct list *list)
+{
+	if (l->state == LI_READY) {
+		LIST_ADDQ(list, &l->wait_queue);
+		fd_stop_recv(l->fd);
+		l->state = LI_LIMITED;
+	}
+}
+
+/* This function adds all of the protocol's listener's file descriptors to the
+ * polling lists when they are in the LI_LISTEN state. It is intended to be
+ * used as a protocol's generic enable_all() primitive, for use after the
+ * fork(). It puts the listeners into LI_READY or LI_FULL states depending on
+ * their number of connections. It always returns ERR_NONE.
+ */
+int enable_all_listeners(struct protocol *proto)
+{
+	struct listener *listener;
+
+	list_for_each_entry(listener, &proto->listeners, proto_list)
+		enable_listener(listener);
+	return ERR_NONE;
+}
+
+/* This function removes all of the protocol's listener's file descriptors from
+ * the polling lists when they are in the LI_READY or LI_FULL states. It is
+ * intended to be used as a protocol's generic disable_all() primitive. It puts
+ * the listeners into LI_LISTEN, and always returns ERR_NONE.
+ */
+int disable_all_listeners(struct protocol *proto)
+{
+	struct listener *listener;
+
+	list_for_each_entry(listener, &proto->listeners, proto_list)
+		disable_listener(listener);
+	return ERR_NONE;
+}
+
+/* Dequeues all of the listeners waiting for a resource in wait queue <queue>. */
+void dequeue_all_listeners(struct list *list)
+{
+	struct listener *listener, *l_back;
+
+	list_for_each_entry_safe(listener, l_back, list, wait_queue) {
+		/* This cannot fail because the listeners are by definition in
+		 * the LI_LIMITED state. The function also removes the entry
+		 * from the queue.
+		 */
+		resume_listener(listener);
+	}
+}
+
+/* This function closes the listening socket for the specified listener,
+ * provided that it's already in a listening state. The listener enters the
+ * LI_ASSIGNED state. It always returns ERR_NONE. This function is intended
+ * to be used as a generic function for standard protocols.
+ */
+int unbind_listener(struct listener *listener)
+{
+	if (listener->state == LI_READY)
+		fd_stop_recv(listener->fd);
+
+	if (listener->state == LI_LIMITED)
+		LIST_DEL(&listener->wait_queue);
+
+	if (listener->state >= LI_PAUSED) {
+		fd_delete(listener->fd);
+		listener->state = LI_ASSIGNED;
+	}
+	return ERR_NONE;
+}
+
+/* This function closes all listening sockets bound to the protocol <proto>,
+ * and the listeners end in LI_ASSIGNED state if they were higher. It does not
+ * detach them from the protocol. It always returns ERR_NONE.
+ */
+int unbind_all_listeners(struct protocol *proto)
+{
+	struct listener *listener;
+
+	list_for_each_entry(listener, &proto->listeners, proto_list)
+		unbind_listener(listener);
+	return ERR_NONE;
+}
+
+/* Delete a listener from its protocol's list of listeners. The listener's
+ * state is automatically updated from LI_ASSIGNED to LI_INIT. The protocol's
+ * number of listeners is updated. Note that the listener must have previously
+ * been unbound. This is the generic function to use to remove a listener.
+ */
+void delete_listener(struct listener *listener)
+{
+	if (listener->state != LI_ASSIGNED)
+		return;
+	listener->state = LI_INIT;
+	LIST_DEL(&listener->proto_list);
+	listener->proto->nb_listeners--;
+}
+
+/* This function is called on a read event from a listening socket, corresponding
+ * to an accept. It tries to accept as many connections as possible, and for each
+ * calls the listener's accept handler (generally the frontend's accept handler).
+ */
+void listener_accept(int fd)
+{
+	struct listener *l = fdtab[fd].owner;
+	struct proxy *p = l->frontend;
+	int max_accept = global.tune.maxaccept;
+	int cfd;
+	int ret;
+
+	if (unlikely(l->nbconn >= l->maxconn)) {
+		listener_full(l);
+		return;
+	}
+
+	if (global.cps_lim && !(l->options & LI_O_UNLIMITED)) {
+		int max = freq_ctr_remain(&global.conn_per_sec, global.cps_lim, 0);
+
+		if (unlikely(!max)) {
+			/* frontend accept rate limit was reached */
+			limit_listener(l, &global_listener_queue);
+			task_schedule(global_listener_queue_task, tick_add(now_ms, next_event_delay(&global.conn_per_sec, global.cps_lim, 0)));
+			return;
+		}
+
+		if (max_accept > max)
+			max_accept = max;
+	}
+
+	if (p && p->fe_sps_lim) {
+		int max = freq_ctr_remain(&p->fe_sess_per_sec, p->fe_sps_lim, 0);
+
+		if (unlikely(!max)) {
+			/* frontend accept rate limit was reached */
+			limit_listener(l, &p->listener_queue);
+			task_schedule(p->task, tick_add(now_ms, next_event_delay(&p->fe_sess_per_sec, p->fe_sps_lim, 0)));
+			return;
+		}
+
+		if (max_accept > max)
+			max_accept = max;
+	}
+
+	/* Note: if we fail to allocate a connection because of configured
+	 * limits, we'll schedule a new attempt worst 1 second later in the
+	 * worst case. If we fail due to system limits or temporary resource
+	 * shortage, we try again 100ms later in the worst case.
+	 */
+	while (max_accept--) {
+		struct sockaddr_storage addr;
+		socklen_t laddr = sizeof(addr);
+
+		if (unlikely(actconn >= global.maxconn) && !(l->options & LI_O_UNLIMITED)) {
+			limit_listener(l, &global_listener_queue);
+			task_schedule(global_listener_queue_task, tick_add(now_ms, 1000)); /* try again in 1 second */
+			return;
+		}
+
+		if (unlikely(p && p->feconn >= p->maxconn)) {
+			limit_listener(l, &p->listener_queue);
+			return;
+		}
+
+		cfd = accept(fd, (struct sockaddr *)&addr, &laddr);
+		if (unlikely(cfd == -1)) {
+			switch (errno) {
+			case EAGAIN:
+			case EINTR:
+			case ECONNABORTED:
+				fd_poll_recv(fd);
+				return;   /* nothing more to accept */
+			case ENFILE:
+				if (p)
+					send_log(p, LOG_EMERG,
+						 "Proxy %s reached system FD limit at %d. Please check system tunables.\n",
+						 p->id, maxfd);
+				limit_listener(l, &global_listener_queue);
+				task_schedule(global_listener_queue_task, tick_add(now_ms, 100)); /* try again in 100 ms */
+				return;
+			case EMFILE:
+				if (p)
+					send_log(p, LOG_EMERG,
+						 "Proxy %s reached process FD limit at %d. Please check 'ulimit-n' and restart.\n",
+						 p->id, maxfd);
+				limit_listener(l, &global_listener_queue);
+				task_schedule(global_listener_queue_task, tick_add(now_ms, 100)); /* try again in 100 ms */
+				return;
+			case ENOBUFS:
+			case ENOMEM:
+				if (p)
+					send_log(p, LOG_EMERG,
+						 "Proxy %s reached system memory limit at %d sockets. Please check system tunables.\n",
+						 p->id, maxfd);
+				limit_listener(l, &global_listener_queue);
+				task_schedule(global_listener_queue_task, tick_add(now_ms, 100)); /* try again in 100 ms */
+				return;
+			default:
+				/* unexpected result, let's go back to poll */
+				fd_poll_recv(fd);
+				return;
+			}
+		}
+
+		/* if this connection comes from a known monitoring system, we want to ignore
+		 * it as soon as possible, which means closing it immediately if it is only a
+		 * TCP-based monitoring check.
+		 */
+		if (unlikely((l->options & LI_O_CHK_MONNET) &&
+			     (p->mode == PR_MODE_TCP) &&
+			     addr.ss_family == AF_INET &&
+			     (((struct sockaddr_in *)&addr)->sin_addr.s_addr & p->mon_mask.s_addr) == p->mon_net.s_addr)) {
+			close(cfd);
+			continue;
+		}
+
+		if (unlikely(cfd >= global.maxsock)) {
+			send_log(p, LOG_EMERG,
+				 "Proxy %s reached the configured maximum connection limit. Please check the global 'maxconn' value.\n",
+				 p->id);
+			close(cfd);
+			limit_listener(l, &global_listener_queue);
+			task_schedule(global_listener_queue_task, tick_add(now_ms, 1000)); /* try again in 1 second */
+			return;
+		}
+
+		/* increase the per-process number of cumulated connections */
+		if (!(l->options & LI_O_UNLIMITED)) {
+			update_freq_ctr(&global.conn_per_sec, 1);
+			if (global.conn_per_sec.curr_ctr > global.cps_max)
+				global.cps_max = global.conn_per_sec.curr_ctr;
+			actconn++;
+		}
+
+		jobs++;
+		totalconn++;
+		l->nbconn++;
+
+		if (l->counters) {
+			if (l->nbconn > l->counters->conn_max)
+				l->counters->conn_max = l->nbconn;
+		}
+
+		ret = l->accept(l, cfd, &addr);
+		if (unlikely(ret <= 0)) {
+			/* The connection was closed by session_accept(). Either
+			 * we just have to ignore it (ret == 0) or it's a critical
+			 * error due to a resource shortage, and we must stop the
+			 * listener (ret < 0).
+			 */
+			if (!(l->options & LI_O_UNLIMITED))
+				actconn--;
+			jobs--;
+			l->nbconn--;
+			if (ret == 0) /* successful termination */
+				continue;
+
+			limit_listener(l, &global_listener_queue);
+			task_schedule(global_listener_queue_task, tick_add(now_ms, 100)); /* try again in 100 ms */
+			return;
+		}
+
+		if (l->nbconn >= l->maxconn) {
+			listener_full(l);
+			return;
+		}
+
+	} /* end of while (max_accept--) */
+
+	/* we've exhausted max_accept, so there is no need to poll again */
+	return;
+}
+
+/************************************************************************/
+/*           All supported ACL keywords must be declared here.          */
+/************************************************************************/
+
+/* set temp integer to the number of connexions to the same listening socket */
+static int
+acl_fetch_dconn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,
+                const struct arg *args, struct sample *smp)
+{
+	smp->type = SMP_T_UINT;
+	smp->data.uint = l4->listener->nbconn;
+	return 1;
+}
+
+/* set temp integer to the id of the socket (listener) */
+static int
+acl_fetch_so_id(struct proxy *px, struct session *l4, void *l7, unsigned int opt,
+                const struct arg *args, struct sample *smp)
+{
+	smp->type = SMP_T_UINT;
+	smp->data.uint = l4->listener->luid;
+	return 1;
+}
+
+/* Note: must not be declared <const> as its list will be overwritten.
+ * Please take care of keeping this list alphabetically sorted.
+ */
+static struct acl_kw_list acl_kws = {{ },{
+	{ "dst_conn",   acl_parse_int,   acl_fetch_dconn,    acl_match_int, ACL_USE_NOTHING, 0 },
+	{ "so_id",      acl_parse_int,   acl_fetch_so_id,    acl_match_int, ACL_USE_NOTHING, 0 },
+	{ NULL, NULL, NULL, NULL },
+}};
+
+__attribute__((constructor))
+static void __listener_init(void)
+{
+	acl_register_keywords(&acl_kws);
+}
+
+/*
+ * Local variables:
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ * End:
+ */
diff --git a/src/peers.c b/src/peers.c
index 6af5d9c..09e45f7 100644
--- a/src/peers.c
+++ b/src/peers.c
@@ -25,6 +25,7 @@
 #include <common/time.h>
 
 #include <types/global.h>
+#include <proto/listener.h>
 #include <types/peers.h>
 
 #include <proto/acl.h>
@@ -32,7 +33,6 @@
 #include <proto/fd.h>
 #include <proto/log.h>
 #include <proto/hdr_idx.h>
-#include <proto/protocols.h>
 #include <proto/proto_tcp.h>
 #include <proto/proto_http.h>
 #include <proto/proxy.h>
diff --git a/src/proto_tcp.c b/src/proto_tcp.c
index f819147..092db69 100644
--- a/src/proto_tcp.c
+++ b/src/proto_tcp.c
@@ -42,9 +42,10 @@
 #include <proto/channel.h>
 #include <proto/connection.h>
 #include <proto/fd.h>
+#include <proto/listener.h>
 #include <proto/log.h>
 #include <proto/port_range.h>
-#include <proto/protocols.h>
+#include <proto/protocol.h>
 #include <proto/proto_tcp.h>
 #include <proto/proxy.h>
 #include <proto/sample.h>
diff --git a/src/proto_uxst.c b/src/proto_uxst.c
index e4aaeed..ed05e02 100644
--- a/src/proto_uxst.c
+++ b/src/proto_uxst.c
@@ -36,8 +36,9 @@
 #include <types/global.h>
 
 #include <proto/fd.h>
+#include <proto/listener.h>
 #include <proto/log.h>
-#include <proto/protocols.h>
+#include <proto/protocol.h>
 #include <proto/proto_uxst.h>
 #include <proto/task.h>
 
diff --git a/src/protocol.c b/src/protocol.c
new file mode 100644
index 0000000..84d23da
--- /dev/null
+++ b/src/protocol.c
@@ -0,0 +1,129 @@
+/*
+ * Protocol registration functions.
+ *
+ * Copyright 2000-2012 Willy Tarreau <w@1wt.eu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <common/config.h>
+#include <common/errors.h>
+#include <common/mini-clist.h>
+#include <common/standard.h>
+
+#include <types/protocol.h>
+
+/* List head of all registered protocols */
+static struct list protocols = LIST_HEAD_INIT(protocols);
+
+/* Registers the protocol <proto> */
+void protocol_register(struct protocol *proto)
+{
+	LIST_ADDQ(&protocols, &proto->list);
+}
+
+/* Unregisters the protocol <proto>. Note that all listeners must have
+ * previously been unbound.
+ */
+void protocol_unregister(struct protocol *proto)
+{
+	LIST_DEL(&proto->list);
+	LIST_INIT(&proto->list);
+}
+
+/* binds all listeners of all registered protocols. Returns a composition
+ * of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
+ */
+int protocol_bind_all(char *errmsg, int errlen)
+{
+	struct protocol *proto;
+	int err;
+
+	err = 0;
+	list_for_each_entry(proto, &protocols, list) {
+		if (proto->bind_all) {
+			err |= proto->bind_all(proto, errmsg, errlen);
+			if ( err & ERR_ABORT )
+				break;
+		}
+	}
+	return err;
+}
+
+/* unbinds all listeners of all registered protocols. They are also closed.
+ * This must be performed before calling exit() in order to get a chance to
+ * remove file-system based sockets and pipes.
+ * Returns a composition of ERR_NONE, ERR_RETRYABLE, ERR_FATAL, ERR_ABORT.
+ */
+int protocol_unbind_all(void)
+{
+	struct protocol *proto;
+	int err;
+
+	err = 0;
+	list_for_each_entry(proto, &protocols, list) {
+		if (proto->unbind_all) {
+			err |= proto->unbind_all(proto);
+		}
+	}
+	return err;
+}
+
+/* enables all listeners of all registered protocols. This is intended to be
+ * used after a fork() to enable reading on all file descriptors. Returns a
+ * composition of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
+ */
+int protocol_enable_all(void)
+{
+	struct protocol *proto;
+	int err;
+
+	err = 0;
+	list_for_each_entry(proto, &protocols, list) {
+		if (proto->enable_all) {
+			err |= proto->enable_all(proto);
+		}
+	}
+	return err;
+}
+
+/* disables all listeners of all registered protocols. This may be used before
+ * a fork() to avoid duplicating poll lists. Returns a composition of ERR_NONE,
+ * ERR_RETRYABLE, ERR_FATAL.
+ */
+int protocol_disable_all(void)
+{
+	struct protocol *proto;
+	int err;
+
+	err = 0;
+	list_for_each_entry(proto, &protocols, list) {
+		if (proto->disable_all) {
+			err |= proto->disable_all(proto);
+		}
+	}
+	return err;
+}
+
+/* Returns the protocol handler for socket family <family> or NULL if not found */
+struct protocol *protocol_by_family(int family)
+{
+	struct protocol *proto;
+
+	list_for_each_entry(proto, &protocols, list) {
+		if (proto->sock_domain == family)
+			return proto;
+	}
+	return NULL;
+}
+
+/*
+ * Local variables:
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ * End:
+ */
diff --git a/src/protocols.c b/src/protocols.c
deleted file mode 100644
index 377c985..0000000
--- a/src/protocols.c
+++ /dev/null
@@ -1,559 +0,0 @@
-/*
- * Protocol registration and listener management functions.
- *
- * Copyright 2000-2010 Willy Tarreau <w@1wt.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <string.h>
-
-#include <common/config.h>
-#include <common/errors.h>
-#include <common/mini-clist.h>
-#include <common/standard.h>
-#include <common/time.h>
-
-#include <types/global.h>
-
-#include <proto/acl.h>
-#include <proto/fd.h>
-#include <proto/freq_ctr.h>
-#include <proto/log.h>
-#include <proto/task.h>
-
-/* List head of all registered protocols */
-static struct list protocols = LIST_HEAD_INIT(protocols);
-
-/* This function adds the specified listener's file descriptor to the polling
- * lists if it is in the LI_LISTEN state. The listener enters LI_READY or
- * LI_FULL state depending on its number of connections.
- */
-void enable_listener(struct listener *listener)
-{
-	if (listener->state == LI_LISTEN) {
-		if (listener->nbconn < listener->maxconn) {
-			fd_want_recv(listener->fd);
-			listener->state = LI_READY;
-		} else {
-			listener->state = LI_FULL;
-		}
-	}
-}
-
-/* This function removes the specified listener's file descriptor from the
- * polling lists if it is in the LI_READY or in the LI_FULL state. The listener
- * enters LI_LISTEN.
- */
-void disable_listener(struct listener *listener)
-{
-	if (listener->state < LI_READY)
-		return;
-	if (listener->state == LI_READY)
-		fd_stop_recv(listener->fd);
-	if (listener->state == LI_LIMITED)
-		LIST_DEL(&listener->wait_queue);
-	listener->state = LI_LISTEN;
-}
-
-/* This function tries to temporarily disable a listener, depending on the OS
- * capabilities. Linux unbinds the listen socket after a SHUT_RD, and ignores
- * SHUT_WR. Solaris refuses either shutdown(). OpenBSD ignores SHUT_RD but
- * closes upon SHUT_WR and refuses to rebind. So a common validation path
- * involves SHUT_WR && listen && SHUT_RD. In case of success, the FD's polling
- * is disabled. It normally returns non-zero, unless an error is reported.
- */
-int pause_listener(struct listener *l)
-{
-	if (l->state <= LI_PAUSED)
-		return 1;
-
-	if (shutdown(l->fd, SHUT_WR) != 0)
-		return 0; /* Solaris dies here */
-
-	if (listen(l->fd, l->backlog ? l->backlog : l->maxconn) != 0)
-		return 0; /* OpenBSD dies here */
-
-	if (shutdown(l->fd, SHUT_RD) != 0)
-		return 0; /* should always be OK */
-
-	if (l->state == LI_LIMITED)
-		LIST_DEL(&l->wait_queue);
-
-	fd_stop_recv(l->fd);
-	l->state = LI_PAUSED;
-	return 1;
-}
-
-/* This function tries to resume a temporarily disabled listener. Paused, full,
- * limited and disabled listeners are handled, which means that this function
- * may replace enable_listener(). The resulting state will either be LI_READY
- * or LI_FULL. 0 is returned in case of failure to resume (eg: dead socket).
- */
-int resume_listener(struct listener *l)
-{
-	if (l->state < LI_PAUSED)
-		return 0;
-
-	if (l->state == LI_PAUSED &&
-	    listen(l->fd, l->backlog ? l->backlog : l->maxconn) != 0)
-		return 0;
-
-	if (l->state == LI_READY)
-		return 1;
-
-	if (l->state == LI_LIMITED)
-		LIST_DEL(&l->wait_queue);
-
-	if (l->nbconn >= l->maxconn) {
-		l->state = LI_FULL;
-		return 1;
-	}
-
-	fd_want_recv(l->fd);
-	l->state = LI_READY;
-	return 1;
-}
-
-/* Marks a ready listener as full so that the session code tries to re-enable
- * it upon next close() using resume_listener().
- */
-void listener_full(struct listener *l)
-{
-	if (l->state >= LI_READY) {
-		if (l->state == LI_LIMITED)
-			LIST_DEL(&l->wait_queue);
-
-		fd_stop_recv(l->fd);
-		l->state = LI_FULL;
-	}
-}
-
-/* Marks a ready listener as limited so that we only try to re-enable it when
- * resources are free again. It will be queued into the specified queue.
- */
-void limit_listener(struct listener *l, struct list *list)
-{
-	if (l->state == LI_READY) {
-		LIST_ADDQ(list, &l->wait_queue);
-		fd_stop_recv(l->fd);
-		l->state = LI_LIMITED;
-	}
-}
-
-/* This function adds all of the protocol's listener's file descriptors to the
- * polling lists when they are in the LI_LISTEN state. It is intended to be
- * used as a protocol's generic enable_all() primitive, for use after the
- * fork(). It puts the listeners into LI_READY or LI_FULL states depending on
- * their number of connections. It always returns ERR_NONE.
- */
-int enable_all_listeners(struct protocol *proto)
-{
-	struct listener *listener;
-
-	list_for_each_entry(listener, &proto->listeners, proto_list)
-		enable_listener(listener);
-	return ERR_NONE;
-}
-
-/* This function removes all of the protocol's listener's file descriptors from
- * the polling lists when they are in the LI_READY or LI_FULL states. It is
- * intended to be used as a protocol's generic disable_all() primitive. It puts
- * the listeners into LI_LISTEN, and always returns ERR_NONE.
- */
-int disable_all_listeners(struct protocol *proto)
-{
-	struct listener *listener;
-
-	list_for_each_entry(listener, &proto->listeners, proto_list)
-		disable_listener(listener);
-	return ERR_NONE;
-}
-
-/* Dequeues all of the listeners waiting for a resource in wait queue <queue>. */
-void dequeue_all_listeners(struct list *list)
-{
-	struct listener *listener, *l_back;
-
-	list_for_each_entry_safe(listener, l_back, list, wait_queue) {
-		/* This cannot fail because the listeners are by definition in
-		 * the LI_LIMITED state. The function also removes the entry
-		 * from the queue.
-		 */
-		resume_listener(listener);
-	}
-}
-
-/* This function closes the listening socket for the specified listener,
- * provided that it's already in a listening state. The listener enters the
- * LI_ASSIGNED state. It always returns ERR_NONE. This function is intended
- * to be used as a generic function for standard protocols.
- */
-int unbind_listener(struct listener *listener)
-{
-	if (listener->state == LI_READY)
-		fd_stop_recv(listener->fd);
-
-	if (listener->state == LI_LIMITED)
-		LIST_DEL(&listener->wait_queue);
-
-	if (listener->state >= LI_PAUSED) {
-		fd_delete(listener->fd);
-		listener->state = LI_ASSIGNED;
-	}
-	return ERR_NONE;
-}
-
-/* This function closes all listening sockets bound to the protocol <proto>,
- * and the listeners end in LI_ASSIGNED state if they were higher. It does not
- * detach them from the protocol. It always returns ERR_NONE.
- */
-int unbind_all_listeners(struct protocol *proto)
-{
-	struct listener *listener;
-
-	list_for_each_entry(listener, &proto->listeners, proto_list)
-		unbind_listener(listener);
-	return ERR_NONE;
-}
-
-/* Delete a listener from its protocol's list of listeners. The listener's
- * state is automatically updated from LI_ASSIGNED to LI_INIT. The protocol's
- * number of listeners is updated. Note that the listener must have previously
- * been unbound. This is the generic function to use to remove a listener.
- */
-void delete_listener(struct listener *listener)
-{
-	if (listener->state != LI_ASSIGNED)
-		return;
-	listener->state = LI_INIT;
-	LIST_DEL(&listener->proto_list);
-	listener->proto->nb_listeners--;
-}
-
-/* This function is called on a read event from a listening socket, corresponding
- * to an accept. It tries to accept as many connections as possible, and for each
- * calls the listener's accept handler (generally the frontend's accept handler).
- */
-void listener_accept(int fd)
-{
-	struct listener *l = fdtab[fd].owner;
-	struct proxy *p = l->frontend;
-	int max_accept = global.tune.maxaccept;
-	int cfd;
-	int ret;
-
-	if (unlikely(l->nbconn >= l->maxconn)) {
-		listener_full(l);
-		return;
-	}
-
-	if (global.cps_lim && !(l->options & LI_O_UNLIMITED)) {
-		int max = freq_ctr_remain(&global.conn_per_sec, global.cps_lim, 0);
-
-		if (unlikely(!max)) {
-			/* frontend accept rate limit was reached */
-			limit_listener(l, &global_listener_queue);
-			task_schedule(global_listener_queue_task, tick_add(now_ms, next_event_delay(&global.conn_per_sec, global.cps_lim, 0)));
-			return;
-		}
-
-		if (max_accept > max)
-			max_accept = max;
-	}
-
-	if (p && p->fe_sps_lim) {
-		int max = freq_ctr_remain(&p->fe_sess_per_sec, p->fe_sps_lim, 0);
-
-		if (unlikely(!max)) {
-			/* frontend accept rate limit was reached */
-			limit_listener(l, &p->listener_queue);
-			task_schedule(p->task, tick_add(now_ms, next_event_delay(&p->fe_sess_per_sec, p->fe_sps_lim, 0)));
-			return;
-		}
-
-		if (max_accept > max)
-			max_accept = max;
-	}
-
-	/* Note: if we fail to allocate a connection because of configured
-	 * limits, we'll schedule a new attempt worst 1 second later in the
-	 * worst case. If we fail due to system limits or temporary resource
-	 * shortage, we try again 100ms later in the worst case.
-	 */
-	while (max_accept--) {
-		struct sockaddr_storage addr;
-		socklen_t laddr = sizeof(addr);
-
-		if (unlikely(actconn >= global.maxconn) && !(l->options & LI_O_UNLIMITED)) {
-			limit_listener(l, &global_listener_queue);
-			task_schedule(global_listener_queue_task, tick_add(now_ms, 1000)); /* try again in 1 second */
-			return;
-		}
-
-		if (unlikely(p && p->feconn >= p->maxconn)) {
-			limit_listener(l, &p->listener_queue);
-			return;
-		}
-
-		cfd = accept(fd, (struct sockaddr *)&addr, &laddr);
-		if (unlikely(cfd == -1)) {
-			switch (errno) {
-			case EAGAIN:
-			case EINTR:
-			case ECONNABORTED:
-				fd_poll_recv(fd);
-				return;   /* nothing more to accept */
-			case ENFILE:
-				if (p)
-					send_log(p, LOG_EMERG,
-						 "Proxy %s reached system FD limit at %d. Please check system tunables.\n",
-						 p->id, maxfd);
-				limit_listener(l, &global_listener_queue);
-				task_schedule(global_listener_queue_task, tick_add(now_ms, 100)); /* try again in 100 ms */
-				return;
-			case EMFILE:
-				if (p)
-					send_log(p, LOG_EMERG,
-						 "Proxy %s reached process FD limit at %d. Please check 'ulimit-n' and restart.\n",
-						 p->id, maxfd);
-				limit_listener(l, &global_listener_queue);
-				task_schedule(global_listener_queue_task, tick_add(now_ms, 100)); /* try again in 100 ms */
-				return;
-			case ENOBUFS:
-			case ENOMEM:
-				if (p)
-					send_log(p, LOG_EMERG,
-						 "Proxy %s reached system memory limit at %d sockets. Please check system tunables.\n",
-						 p->id, maxfd);
-				limit_listener(l, &global_listener_queue);
-				task_schedule(global_listener_queue_task, tick_add(now_ms, 100)); /* try again in 100 ms */
-				return;
-			default:
-				/* unexpected result, let's go back to poll */
-				fd_poll_recv(fd);
-				return;
-			}
-		}
-
-		/* if this connection comes from a known monitoring system, we want to ignore
-		 * it as soon as possible, which means closing it immediately if it is only a
-		 * TCP-based monitoring check.
-		 */
-		if (unlikely((l->options & LI_O_CHK_MONNET) &&
-			     (p->mode == PR_MODE_TCP) &&
-			     addr.ss_family == AF_INET &&
-			     (((struct sockaddr_in *)&addr)->sin_addr.s_addr & p->mon_mask.s_addr) == p->mon_net.s_addr)) {
-			close(cfd);
-			continue;
-		}
-
-		if (unlikely(cfd >= global.maxsock)) {
-			send_log(p, LOG_EMERG,
-				 "Proxy %s reached the configured maximum connection limit. Please check the global 'maxconn' value.\n",
-				 p->id);
-			close(cfd);
-			limit_listener(l, &global_listener_queue);
-			task_schedule(global_listener_queue_task, tick_add(now_ms, 1000)); /* try again in 1 second */
-			return;
-		}
-
-		/* increase the per-process number of cumulated connections */
-		if (!(l->options & LI_O_UNLIMITED)) {
-			update_freq_ctr(&global.conn_per_sec, 1);
-			if (global.conn_per_sec.curr_ctr > global.cps_max)
-				global.cps_max = global.conn_per_sec.curr_ctr;
-			actconn++;
-		}
-
-		jobs++;
-		totalconn++;
-		l->nbconn++;
-
-		if (l->counters) {
-			if (l->nbconn > l->counters->conn_max)
-				l->counters->conn_max = l->nbconn;
-		}
-
-		ret = l->accept(l, cfd, &addr);
-		if (unlikely(ret <= 0)) {
-			/* The connection was closed by session_accept(). Either
-			 * we just have to ignore it (ret == 0) or it's a critical
-			 * error due to a resource shortage, and we must stop the
-			 * listener (ret < 0).
-			 */
-			if (!(l->options & LI_O_UNLIMITED))
-				actconn--;
-			jobs--;
-			l->nbconn--;
-			if (ret == 0) /* successful termination */
-				continue;
-
-			limit_listener(l, &global_listener_queue);
-			task_schedule(global_listener_queue_task, tick_add(now_ms, 100)); /* try again in 100 ms */
-			return;
-		}
-
-		if (l->nbconn >= l->maxconn) {
-			listener_full(l);
-			return;
-		}
-
-	} /* end of while (max_accept--) */
-
-	/* we've exhausted max_accept, so there is no need to poll again */
-	return;
-}
-
-/* Registers the protocol <proto> */
-void protocol_register(struct protocol *proto)
-{
-	LIST_ADDQ(&protocols, &proto->list);
-}
-
-/* Unregisters the protocol <proto>. Note that all listeners must have
- * previously been unbound.
- */
-void protocol_unregister(struct protocol *proto)
-{
-	LIST_DEL(&proto->list);
-	LIST_INIT(&proto->list);
-}
-
-/* binds all listeners of all registered protocols. Returns a composition
- * of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_bind_all(char *errmsg, int errlen)
-{
-	struct protocol *proto;
-	int err;
-
-	err = 0;
-	list_for_each_entry(proto, &protocols, list) {
-		if (proto->bind_all) {
-			err |= proto->bind_all(proto, errmsg, errlen);
-			if ( err & ERR_ABORT )
-				break;
-		}
-	}
-	return err;
-}
-
-/* unbinds all listeners of all registered protocols. They are also closed.
- * This must be performed before calling exit() in order to get a chance to
- * remove file-system based sockets and pipes.
- * Returns a composition of ERR_NONE, ERR_RETRYABLE, ERR_FATAL, ERR_ABORT.
- */
-int protocol_unbind_all(void)
-{
-	struct protocol *proto;
-	int err;
-
-	err = 0;
-	list_for_each_entry(proto, &protocols, list) {
-		if (proto->unbind_all) {
-			err |= proto->unbind_all(proto);
-		}
-	}
-	return err;
-}
-
-/* enables all listeners of all registered protocols. This is intended to be
- * used after a fork() to enable reading on all file descriptors. Returns a
- * composition of ERR_NONE, ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_enable_all(void)
-{
-	struct protocol *proto;
-	int err;
-
-	err = 0;
-	list_for_each_entry(proto, &protocols, list) {
-		if (proto->enable_all) {
-			err |= proto->enable_all(proto);
-		}
-	}
-	return err;
-}
-
-/* disables all listeners of all registered protocols. This may be used before
- * a fork() to avoid duplicating poll lists. Returns a composition of ERR_NONE,
- * ERR_RETRYABLE, ERR_FATAL.
- */
-int protocol_disable_all(void)
-{
-	struct protocol *proto;
-	int err;
-
-	err = 0;
-	list_for_each_entry(proto, &protocols, list) {
-		if (proto->disable_all) {
-			err |= proto->disable_all(proto);
-		}
-	}
-	return err;
-}
-
-/* Returns the protocol handler for socket family <family> or NULL if not found */
-struct protocol *protocol_by_family(int family)
-{
-	struct protocol *proto;
-
-	list_for_each_entry(proto, &protocols, list) {
-		if (proto->sock_domain == family)
-			return proto;
-	}
-	return NULL;
-}
-
-/************************************************************************/
-/*           All supported ACL keywords must be declared here.          */
-/************************************************************************/
-
-/* set temp integer to the number of connexions to the same listening socket */
-static int
-acl_fetch_dconn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,
-                const struct arg *args, struct sample *smp)
-{
-	smp->type = SMP_T_UINT;
-	smp->data.uint = l4->listener->nbconn;
-	return 1;
-}
-
-/* set temp integer to the id of the socket (listener) */
-static int
-acl_fetch_so_id(struct proxy *px, struct session *l4, void *l7, unsigned int opt,
-                const struct arg *args, struct sample *smp)
-{
-	smp->type = SMP_T_UINT;
-	smp->data.uint = l4->listener->luid;
-	return 1;
-}
-
-/* Note: must not be declared <const> as its list will be overwritten.
- * Please take care of keeping this list alphabetically sorted.
- */
-static struct acl_kw_list acl_kws = {{ },{
-	{ "dst_conn",   acl_parse_int,   acl_fetch_dconn,    acl_match_int, ACL_USE_NOTHING, 0 },
-	{ "so_id",      acl_parse_int,   acl_fetch_so_id,    acl_match_int, ACL_USE_NOTHING, 0 },
-	{ NULL, NULL, NULL, NULL },
-}};
-
-__attribute__((constructor))
-static void __protocols_init(void)
-{
-	acl_register_keywords(&acl_kws);
-}
-
-/*
- * Local variables:
- *  c-indent-level: 8
- *  c-basic-offset: 8
- * End:
- */
diff --git a/src/proxy.c b/src/proxy.c
index 07e863c..56d343e 100644
--- a/src/proxy.c
+++ b/src/proxy.c
@@ -31,8 +31,8 @@
 #include <proto/backend.h>
 #include <proto/fd.h>
 #include <proto/hdr_idx.h>
+#include <proto/listener.h>
 #include <proto/log.h>
-#include <proto/protocols.h>
 #include <proto/proto_tcp.h>
 #include <proto/proto_http.h>
 #include <proto/proxy.h>
diff --git a/src/raw_sock.c b/src/raw_sock.c
index ea2fa66..37bea72 100644
--- a/src/raw_sock.c
+++ b/src/raw_sock.c
@@ -35,7 +35,6 @@
 #include <proto/freq_ctr.h>
 #include <proto/log.h>
 #include <proto/pipe.h>
-#include <proto/protocols.h>
 #include <proto/raw_sock.h>
 #include <proto/stream_interface.h>
 #include <proto/task.h>
diff --git a/src/session.c b/src/session.c
index 4503b41..6fb79e3 100644
--- a/src/session.c
+++ b/src/session.c
@@ -32,11 +32,11 @@
 #include <proto/freq_ctr.h>
 #include <proto/frontend.h>
 #include <proto/hdr_idx.h>
+#include <proto/listener.h>
 #include <proto/log.h>
 #include <proto/raw_sock.h>
 #include <proto/session.h>
 #include <proto/pipe.h>
-#include <proto/protocols.h>
 #include <proto/proto_http.h>
 #include <proto/proto_tcp.h>
 #include <proto/proxy.h>
diff --git a/src/ssl_sock.c b/src/ssl_sock.c
index 4198339..5f259f3 100644
--- a/src/ssl_sock.c
+++ b/src/ssl_sock.c
@@ -64,7 +64,6 @@
 #include <proto/freq_ctr.h>
 #include <proto/frontend.h>
 #include <proto/log.h>
-#include <proto/protocols.h>
 #include <proto/shctx.h>
 #include <proto/ssl_sock.h>
 #include <proto/task.h>
-- 
1.7.1

